// Generated by tmpl
// https://github.com/benbjohnson/tmpl

package influxql_test

import (
	"testing"

	"github.com/davecgh/go-spew/spew"
	"github.com/influxdb/influxdb/influxql"
	"github.com/influxdb/influxdb/pkg/deep"
)

// Test implementation of influxql.FloatIterator
type FloatIterator struct {
	Points []influxql.FloatPoint
}

// Close is a no-op.
func (itr *FloatIterator) Close() error { return nil }

// Next returns the next value and shifts it off the beginning of the points slice.
func (itr *FloatIterator) Next() *influxql.FloatPoint {
	if len(itr.Points) == 0 {
		return nil
	}

	v := &itr.Points[0]
	itr.Points = itr.Points[1:]
	return v
}

type TestFloatIterator struct {
	Iterator influxql.Iterator
	Points   []influxql.FloatPoint
}

func (ti *TestFloatIterator) run(t *testing.T) {
	itr := ti.Iterator.(influxql.FloatIterator)

	points := make([]influxql.FloatPoint, 0, len(ti.Points))
	for p := itr.Next(); p != nil; p = itr.Next() {
		points = append(points, *p)
	}

	if !deep.Equal(ti.Points, points) {
		t.Fatalf("unexpected points: %s %s", spew.Sdump(points), spew.Sdump(ti.Points))
	}
}

// Test implementation of influxql.IntegerIterator
type IntegerIterator struct {
	Points []influxql.IntegerPoint
}

// Close is a no-op.
func (itr *IntegerIterator) Close() error { return nil }

// Next returns the next value and shifts it off the beginning of the points slice.
func (itr *IntegerIterator) Next() *influxql.IntegerPoint {
	if len(itr.Points) == 0 {
		return nil
	}

	v := &itr.Points[0]
	itr.Points = itr.Points[1:]
	return v
}

type TestIntegerIterator struct {
	Iterator influxql.Iterator
	Points   []influxql.IntegerPoint
}

func (ti *TestIntegerIterator) run(t *testing.T) {
	itr := ti.Iterator.(influxql.IntegerIterator)

	points := make([]influxql.IntegerPoint, 0, len(ti.Points))
	for p := itr.Next(); p != nil; p = itr.Next() {
		points = append(points, *p)
	}

	if !deep.Equal(ti.Points, points) {
		t.Fatalf("unexpected points: %s %s", spew.Sdump(points), spew.Sdump(ti.Points))
	}
}

// Test implementation of influxql.StringIterator
type StringIterator struct {
	Points []influxql.StringPoint
}

// Close is a no-op.
func (itr *StringIterator) Close() error { return nil }

// Next returns the next value and shifts it off the beginning of the points slice.
func (itr *StringIterator) Next() *influxql.StringPoint {
	if len(itr.Points) == 0 {
		return nil
	}

	v := &itr.Points[0]
	itr.Points = itr.Points[1:]
	return v
}

type TestStringIterator struct {
	Iterator influxql.Iterator
	Points   []influxql.StringPoint
}

func (ti *TestStringIterator) run(t *testing.T) {
	itr := ti.Iterator.(influxql.StringIterator)

	points := make([]influxql.StringPoint, 0, len(ti.Points))
	for p := itr.Next(); p != nil; p = itr.Next() {
		points = append(points, *p)
	}

	if !deep.Equal(ti.Points, points) {
		t.Fatalf("unexpected points: %s %s", spew.Sdump(points), spew.Sdump(ti.Points))
	}
}

// Test implementation of influxql.BooleanIterator
type BooleanIterator struct {
	Points []influxql.BooleanPoint
}

// Close is a no-op.
func (itr *BooleanIterator) Close() error { return nil }

// Next returns the next value and shifts it off the beginning of the points slice.
func (itr *BooleanIterator) Next() *influxql.BooleanPoint {
	if len(itr.Points) == 0 {
		return nil
	}

	v := &itr.Points[0]
	itr.Points = itr.Points[1:]
	return v
}

type TestBooleanIterator struct {
	Iterator influxql.Iterator
	Points   []influxql.BooleanPoint
}

func (ti *TestBooleanIterator) run(t *testing.T) {
	itr := ti.Iterator.(influxql.BooleanIterator)

	points := make([]influxql.BooleanPoint, 0, len(ti.Points))
	for p := itr.Next(); p != nil; p = itr.Next() {
		points = append(points, *p)
	}

	if !deep.Equal(ti.Points, points) {
		t.Fatalf("unexpected points: %s %s", spew.Sdump(points), spew.Sdump(ti.Points))
	}
}
