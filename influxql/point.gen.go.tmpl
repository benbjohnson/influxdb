package influxql

{{range .}}

// {{.Name}}Point represents a point with a {{.Type}} value.
type {{.Name}}Point struct {
	Name string
	Tags Tags

	Time  int64
	Nil   bool
	Value {{.Type}}
	Aux   []interface{}
}

func (v *{{.Name}}Point) name() string       { return v.Name }
func (v *{{.Name}}Point) tags() Tags         { return v.Tags }
func (v *{{.Name}}Point) time() int64        { return v.Time }
func (v *{{.Name}}Point) nil() bool          { return v.Nil }
func (v *{{.Name}}Point) value() interface{} {
	if v.Nil {
		return nil
	}
	return v.Value
}
func (v *{{.Name}}Point) aux() []interface{} { return v.Aux }

// Clone returns a copy of v.
func (v *{{.Name}}Point) Clone() *{{.Name}}Point {
	if v == nil {
		return nil
	}

	other := *v
	if v.Aux != nil {
		other.Aux = make([]interface{}, len(v.Aux))
		copy(other.Aux, v.Aux)
	}

	return &other
}

// {{.name}}Points represents a slice of points sortable by value.
type {{.name}}Points []{{.Name}}Point

func (a {{.name}}Points) Len() int           { return len(a) }
func (a {{.name}}Points) Less(i, j int) bool { return a[i].Time < a[j].Time }
func (a {{.name}}Points) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// {{.name}}PointsByValue represents a slice of points sortable by value.
type {{.name}}PointsByValue []{{.Name}}Point

func (a {{.name}}PointsByValue) Len() int           { return len(a) }
{{if eq .Name "Boolean"}}
func (a {{.name}}PointsByValue) Less(i, j int) bool { return !a[i].Value }
{{else}}
func (a {{.name}}PointsByValue) Less(i, j int) bool { return a[i].Value < a[j].Value }
{{end}}
func (a {{.name}}PointsByValue) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

// {{.name}}PointByFunc represents a slice of points sortable by a function.
type {{.name}}PointsByFunc struct {
	points []{{.Name}}Point
	cmp    func(a, b *{{.Name}}Point) bool
}

func (a *{{.name}}PointsByFunc) Len() int           { return len(a.points) }
func (a *{{.name}}PointsByFunc) Less(i, j int) bool { return a.cmp(&a.points[i], &a.points[j]) }
func (a *{{.name}}PointsByFunc) Swap(i, j int)      { a.points[i], a.points[j] = a.points[j], a.points[i] }

func (a *{{.name}}PointsByFunc) Push(x interface{}) {
	a.points = append(a.points, x.({{.Name}}Point))
}

func (a *{{.name}}PointsByFunc) Pop() interface{} {
	p := a.points[len(a.points)-1]
	a.points = a.points[:len(a.points)-1]
	return p
}

func {{.name}}PointsSortBy(points []{{.Name}}Point, cmp func(a, b *{{.Name}}Point) bool) *{{.name}}PointsByFunc {
	return &{{.name}}PointsByFunc{
		points: points,
		cmp: cmp,
	}
}

{{end}}
